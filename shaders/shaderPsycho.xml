<?xml version="1.0" encoding="UTF-8"?>

<SHADER name="shaderPsycho">
	<VERTEX>
		// attributes inputs  (vertex arrays)
			attribute vec3 aVertexPosition;
			attribute vec2 aVertexTexCoord;
			attribute vec3 aVertexNormal;
		
		// uniform matrices
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			uniform float uTime;
			
		// output
		varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

		void main(void) {

			vec4 position = uMVMatrix * vec4(aVertexPosition, 1.0);
			//vec4 position = vec4(aVertexPosition, 1.0);

			/*			
			float distance2D = position.x * position.x + position.z * position.z;

			float randomized = ( (uTime / 1000.) * 20. + 36000.0);
			
			position.y += 5.0 * sin(distance2D * sin(randomized / 143.0) / 1000.0);

			float y = position.y;
			float x = position.x;
	
			float om = sin(distance2D * sin(randomized / 256.0) / 5000.0) * sin(randomized / 200.0);
	
			position.y = x * sin(om) + y * cos(om);
			position.x = x * cos(om) - y * sin(om);
			*/
			

			// pass texture coords to fragment shader
			vTextureCoord = aVertexTexCoord;

			float dist = length(position);
			float freq = .3;
			float amplitude = 0.3;

			// wobble and ripple
			position.y += sin(1.0 * 3.14159265 * dist * freq) * amplitude;			
			
			// vNormal
			vNormal = uNMatrix * aVertexNormal;

			vPosition = position;

			// Transform 2D screen-space coords into 3D world-space coords
			gl_Position = uPMatrix * position;
		}

	</VERTEX>
	<FRAGMENT>
		#ifdef GL_ES
		precision highp float;
		#endif

        // Texture sampler
		uniform sampler2D uSampler0;

		// varying input (output of the vertex shader)
		varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

		// ambient Light
		uniform vec3 uAmbientColor;

		// point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

		uniform float uTime;

		// local constant
		float Kd = 0.7;
		float Ks = 0.7;
		float sh = 8.0;
		vec3 specColor = vec3(0.2,0.5,0.7);

		vec4 phong(vec4 texColor) {
			// light direction, eye direction
			vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
			vec3 eyeDirection = normalize(-vPosition.xyz);

			// normalize normal
			vec3 normal = normalize(vNormal);

			// reflection direction
			vec3 reflectDirection = normalize(reflect(-lightDirection,normal));

			//  diffuse term and specular term
			float diffuse = max(dot(normal, lightDirection), 0.0);
			float specular = pow(max(dot(reflectDirection,eyeDirection),0.0),sh);

			// light color
			vec3 lightColor =
				Kd*uAmbientColor*texColor.rgb +
				Kd*diffuse*uPointLightColor0 *texColor.rgb +
				Ks*specular*uPointLightColor0*specColor;

			return vec4(lightColor, texColor.a);
		}
		
		vec2 sineCoords(vec2 texCoords) {
			float amplitude = 0.1;
			float freq = 5.0 * 3.14159265;
			float phi = 50.0 * 3.14159265 / 180.0;
			float tdisp = sin(freq * texCoords.s + phi) * amplitude;
			//float sdisp = sin(freq * texCoords.t + phi) * amplitude;
			return vec2(texCoords.s /*+ sdisp*/, texCoords.t + tdisp);
		}

		vec3 rainbow(float pos) {
			float level = floor((-pos * 0.5 + 0.5) * 6.0);
			float r = float(level &lt;= 2.0) + float(level &gt; 4.0) * 0.5;
			float g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);
			float b = (1.0 - (level - 4.0) * 0.5) * float(level &gt;= 4.0);
			return vec3(r, g, b);
		}

		void main()
		{
			// Apply a wobbly effect on textures
			vec2 wobblyTexCoords = sineCoords(vTextureCoord);
			vec4 texColor = texture2D(uSampler0, wobblyTexCoords);//wobblyTexCoords
			//gl_FragColor = phong(texColor) * vec4(rainbow(vNormal.x), 1.0);
			//gl_FragColor = texColor * vec4(vNormal, 1.0);
			vec4 phongCol = phong(texColor); 
			gl_FragColor =  phongCol * vec4(vNormal, phongCol.a);
		}
	</FRAGMENT>
</SHADER>